package main_test

import (
	"os"
	"os/exec"
	"testing"
)

// Run a simple test to check that the interfacer tool can generate an interface
// from a struct in whatever package.
func TestInterfacer(t *testing.T) {
	// Create a temporary directory for the test
	tempDir := t.TempDir()

	src := `
package client

type client struct {}

func (c *client) DoSomethingB(arg1 string, arg2 int) error {
	return nil
}

func (c *client) DoSomethingA(arg1 string) (string, error) {
	return "", nil
}
`
	srcFile := tempDir + "/client.go"
	if err := os.WriteFile(srcFile, []byte(src), 0644); err != nil {
		t.Fatalf("Failed to write source file: %s", err)
	}

	cmd := exec.Command("go", "run", "github.com/SeaRoll/interfacer/cmd", "-path", tempDir, "-struct", "client", "-file", tempDir+"/interface.go", "-name", "ClientInterface")
	if output, err := cmd.CombinedOutput(); err != nil {
		t.Fatalf("Failed to run interfacer: %s\nOutput: %s", err, output)
	}

	// Check if the output file was created
	outputFile := tempDir + "/interface.go"
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Fatalf("Output file was not created: %s", outputFile)
	}

	// print the output file content for debugging
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %s", err)
	}

	expectedContent := `// Code generated by interfacer, DO NOT EDIT.
package client

// ClientInterface defines the public interface for client.
type ClientInterface interface {
	DoSomethingA(arg1 string) (string, error)
	DoSomethingB(arg1 string, arg2 int) error
}
`

	if string(content) != expectedContent {
		t.Errorf("Generated content does not match expected content.\nExpected:\n%s\nGot:\n%s", expectedContent, string(content))
	}
}
