// Interfacer is a tool to generate an interface from a struct in Go.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

var (
	targetStruct  = flag.String("struct", "service", "The name of the source struct.")
	interfaceName = flag.String("name", "Service", "The name of the interface to generate.")
	outputFile    = flag.String("file", "interface.go", "The name of the output file.")
	sourcePath    = flag.String("path", ".", "The source package directory to scan.")
)

const interfaceTemplate = `// Code generated by interfacer, DO NOT EDIT.
package {{.PackageName}}

// {{.InterfaceName}} defines the public interface for {{.StructName}}.
type {{.InterfaceName}} interface {
{{- range .Methods}}
	{{- range .Docs}}
	// {{.}}
	{{- end}}
	{{.Name}}{{.Signature}}
{{- end}}
}
`

type MethodInfo struct {
	Name      string
	Signature string
	Docs      []string
}

type TemplateData struct {
	PackageName   string
	StructName    string
	InterfaceName string
	Methods       []MethodInfo
}

func main() {
	flag.Parse()

	if *targetStruct == "" || *interfaceName == "" || *outputFile == "" || *sourcePath == "" {
		flag.Usage()
		log.Fatal("All flags are required: -struct, -name, -file, -path")
	}

	fset := token.NewFileSet()
	data := &TemplateData{
		StructName:    *targetStruct,
		InterfaceName: *interfaceName,
	}

	// 2. Parse the entire directory instead of individual files.
	pkgs, err := parser.ParseDir(fset, *sourcePath, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Failed to parse directory %s: %v", *sourcePath, err)
	}

	// 3. Iterate over the packages, files, and AST nodes.
	for _, pkg := range pkgs {
		data.PackageName = pkg.Name // Set the package name for the template.
		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				funcDecl, ok := n.(*ast.FuncDecl)
				// Check if it's a public method with a receiver.
				if !ok || funcDecl.Name == nil || !funcDecl.Name.IsExported() || funcDecl.Recv == nil {
					return true
				}

				// Check if the receiver's type name matches our target struct.
				var receiverTypeName string
				if starExpr, ok := funcDecl.Recv.List[0].Type.(*ast.StarExpr); ok {
					if ident, ok := starExpr.X.(*ast.Ident); ok {
						receiverTypeName = ident.Name
					}
				} else if ident, ok := funcDecl.Recv.List[0].Type.(*ast.Ident); ok {
					receiverTypeName = ident.Name
				}

				if receiverTypeName == *targetStruct {
					var sig bytes.Buffer
					printer.Fprint(&sig, fset, funcDecl.Type)
					methodSignature := strings.TrimPrefix(sig.String(), "func")

					// check if the function has a comment
					var docs []string
					if funcDecl.Doc != nil {
						for _, comment := range funcDecl.Doc.List {
							// Only include comments that are not empty and start with "//"
							if strings.TrimSpace(comment.Text) != "" && strings.HasPrefix(comment.Text, "//") {
								// Remove the "//" prefix and trim whitespace
								docs = append(docs, strings.TrimSpace(strings.TrimPrefix(comment.Text, "//")))
							}
						}
					}

					data.Methods = append(data.Methods, MethodInfo{
						Name:      funcDecl.Name.Name,
						Signature: methodSignature,
						Docs:      docs,
					})
				}
				return true
			})
		}
	}

	// sort methods by name
	if len(data.Methods) > 0 {
		sort.Slice(data.Methods, func(i, j int) bool {
			return data.Methods[i].Name < data.Methods[j].Name
		})
	}

	// 4. Generate the output file.
	tmpl := template.Must(template.New("interface").Parse(interfaceTemplate))
	if err := os.MkdirAll(filepath.Dir(*outputFile), 0o755); err != nil {
		log.Fatalf("Failed to create output directory: %s", err)
	}

	f, err := os.Create(*outputFile)
	if err != nil {
		log.Fatalf("Failed to create output file: %s", err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, data); err != nil {
		panic(fmt.Errorf("failed to execute template: %s", err))
	}

	// 5. Run gofmt on the generated file.
	if err := runGoFmt(*outputFile); err != nil {
		panic(fmt.Errorf("failed to format generated file: %s", err))
	}

	// 6. Run goimports on the generated file.
	if err := runGoImports(*outputFile); err != nil {
		panic(fmt.Errorf("failed to run goimports on generated file: %s", err))
	}

	fmt.Printf("Successfully generated %s from package %s\n", *outputFile, data.PackageName)
}

func runGoFmt(filePath string) error {
	cmd := exec.Command("gofmt", "-w", filePath)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to run gofmt on %s: %w", filePath, err)
	}
	return nil
}

func runGoImports(filePath string) error {
	cmd := exec.Command("go", "run", "golang.org/x/tools/cmd/goimports", "-w", filePath)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to run goimports on %s: %w", filePath, err)
	}
	return nil
}
